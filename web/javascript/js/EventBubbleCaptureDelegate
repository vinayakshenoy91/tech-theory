Describe event bubbling in JavaScript.

HTML:
-----
<html>
<head>
</head>
<body>
  <h1> Event Bubbling Example</h1>
  <div id="Box">
    <button id="myButton">Click Me!</button>
  </div>
</body>
</html

JS:
----
var parent = document.getElementById("Box");
parent.addEventListener("click", function() {
  console.log("Box is clicked");
});
var child = document.getElementById("myButton");
child.addEventListener("click", function() {
  console.log("Button is clicked");
});

In event bubbling, the handler first executes on the event attached to the target element, then on all its ancestors.
It starts from the bottom (deepest layer) and goes to the top.


button -> div ->  body -> HTML -> Document

The Click event will pass in the order shown above. However, for the body, HTML, 
and document no id is defined, and no handler is present in the JavaScript code; hence, you are not able to see any output on the console.


prevent event bubbling: 
e.stopPropagation();
e.cancelBubble;

A bubbling event will propagate upwards from the target element. For example, in the case of a click event, 
it will bubble up until it reaches the document object. However, at any point, 
a handler may decide that the event has been fully processed and stop bubbling. This can be achieved using event.stopProgogation().

Describe event capturing:
--------------------------

html:
<html>
<head>
</head>
<body>
  <h1> Event Capturing Example</h1>
  <div id="Box">
    <button id="myButton">Click Me!</button>
  </div>
</body>
</html>

JS:

var parent = document.getElementById("Box");
parent.addEventListener(
  "click",
  function() {
    console.log("Box is clicked");
  },
  true //Event capturing
);
var child = document.getElementById("myButton");
child.addEventListener("click", function() {
  console.log("Button is clicked");
});

output: 
Box is clicked
Button is clicked


This is due to event capturing in which the handler (addEventListener) runs on the parent first.
 Since in the HTML code button is nested inside div, the event passes down, and the handler runs on the child. 
 In event capturing, when you click the button,
 the event passes from the parent down to the event target, the button (assigned to child).

 Top down approach


 Event delegation using event bubbling:
 --------------------------------------

 <html>
    <head>
    </head>
    <body>
        <ul id="RemoveCartItems">
            <li><a href="#">Item 1</a></li>
            <li><a href="#">Item 2</a></li>
            <li><a href="#">Item 3</a></li>
            <li><a href="#">Item 4</a></li>
            <li><a href="#">Item 5</a></li>
        </ul>
    </body>
</html>

var tar = document.getElementById('RemoveCartItems')
tar.addEventListener('click', function (event) { 
    var ele = event.target.parentNode
    ele.parentNode.removeChild(ele);
    event.preventDefault();
});see


We can have a separate event handler for all five list elements, i.e., for each li tag. This means we will write the 
code for removing each item separately. However, what if we have 1000 items? Or we add new items? Or something in the handler changes? 
In that case, we will have to make the change in the handler of each item. Hence, this is a very inefficient way of 
removing items. This is where event delegation comes in.

Instead of listening for an event on the separate list items, we attach the event handler to the parent element, 
ul, containing all the list items. Now, if you click on a list item, since it will not have any handler of its own, 
the event will bubble up until it reaches the parent ul. The parent has the handler attached to it, so it will be fired. 