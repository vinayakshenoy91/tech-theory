Solution 1:
-----------
function balancedParentheses(str) {
    let stack = [];
    let map = {
        '(': ')',
        '[': ']',
        '{': '}'
    }

    for (let i = 0; i < str.length; i++) {
        // If character is an opening brace add it to a stack
        if (str[i] === '(' || str[i] === '{' || str[i] === '[' ) {
            stack.push(str[i]);
        }
        //if closing brace, pop from stack
        else {
            let lastEle = stack.pop();
            //Return false if the element popped doesnâ€™t match the corresponding closing brace in the map 
            if (str[i] !== map[lastEle]) {return false};
        }
    }
    //if stack not empty at end, return false
    if (stack.length !== 0) {return false};

    return true;
}
console.log(balancedParentheses("{[]()}" ));
console.log(balancedParentheses("{[(])}"));
console.log(balancedParentheses("{[}"));


Solution 2:
-----------



Solution 3:
------------
function balancedParentheses(str) {
  let brackets = str.split("");
  let bracketMap={};

  for(let b of brackets){
   if(bracketMap[b]===undefined){
     bracketMap[b]=1;
   }else{
     let count=bracketMap[b];
     bracketMap[b]=++count;
   }
  }

 let sum = Object.values(bracketMap).reduce((total, currentValue)=>{
    return total +currentValue;
  }, 0);


  if(sum%2!==0){
    return false;
  }
  
   const wrongCombo=["{)","{]","(}","(]","[)","[}"];

   for(let x of wrongCombo){
    if(str.includes(x)){
      return false;
    }
   }

   return true;
}