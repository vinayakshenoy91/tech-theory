Web worker:
-----------
- It is a js file  that runs on a separate thread from the web page thread
- When tab goes away , it dies


Creating a web worker:
----------------------
//Main file

var worker;
worker = new Worker("/js/worker.js");

//Next is we should be abloeo to send and receive messages from it.

worker.addEventListener("message", onMessage);
worker.postMessage({start:true});

function onMessage(evt){
    console.log(evt.data);
    worker.postMessage("Hello from main page");
}

worker.terminate();

//Worker.js
- All the data is copied using structured cloning algo

self.postMessage("Hellwo from web worker");
self.onmesage = onMessage;

function onMessage(evt){
    console.log(evt.data);
}


Service worker:
--------------
-  caching is the basic usecase. Storing web resources like html and css.
-  Prefetching by service workers. Or providing all other details to page along with asked details like depedency injection.
-  Artificial mocking of response for the page.
-  Push notification -> Server tells service worker. Cache and keep the contents for mobile users.
-  Service workers do not have access to local storage. You need to store things in index db
-  If a service worker is stopped and started, it does not go through install and activation phase.
-  Think about handlign request for outside sources, doing opaque request, cache things.




Two cases , where a service worker should work: When offline and when server is not responding or crashed
------------------------------------------------
- At a given point of time, only one service worker can be active.

Detecting online/offline & setting up service worker:
------------------------------------------------------

//Blog.js 

var isOnline=("onLine" in navigator) ? navigator.onLine:true;
var offlineIcon;
var svcWorker;
var usingSW=("serviceWorker" in navigator);
var swRegistration;
var isLoggedIn=false;

document.addEventListener("DOMContentLoaded",ready,false);

initServiceWorker().catch(console.error);

function ready(){
offlineIcon = document.getElementById("connectivity-status");

if(!isOnline){
    offlineIcon.classList.remove("hidden");
}

window.addEventListener("online", function online(){
    offlineIcon.classList.add("hidden");
    isOnline=true;
    sendStatusUpdate();
});


window.addEventListener("offline", function offline(){
    offlineIcon.classList.remove("hidden");
    isOnline=false;
    sendStatusUpdate();
});


}

async initServiceWorker(){
  swRegistration=await navigator.serviceWorker.register("/sw.js"{
      updateViaCache:"none"
  });

  svcWorker=swRegistration.installing || swRegistration.waiting|| swRegistration.active;
  sendStatusUpdate(svcWorker);

  navigator.serviceWorker.addEventListener("controllerchange", function onControllerChange(){
      svcworker=navigator.serviceWorker.controller;
      sendStatusUpdate(svcWorker);
  })

  navigator.serviceWorker.addEventListener("message", onSWMessage);
}

function onSWMessage(evt){
    var {data}=evt;
    if(data.requestStatusUpdate){
       console.log("Received status update request from svc");
       sendStatusUpdate(evt.ports && evt.ports[0]);
    }
}

function sendStatusUpdate(target){
  sendSWMessage({isOnline, isLoggedIn}, target);
}

function sendSWMessage(msg, target){
    if(target){
        target.postMessage(msg); 
    } else if (svcworker){
       svcWorker.postMessage(msg);
    } else{
        navigator.serviceWorker.controller.postMessage(msg);
    }
}

//Sw.js
--------
"use strict";

var version=2;
var cacheName = `ramblings-${version}`;

var urlsToCache= {
    loggedOut:[
       "/css/styles.css",
       "/images/logo.gif",
       "/login",
       "/404"
       "/js/blog.js"
    ];
}

self.addEventListener("install", onInstall);
self.addEventListener("activate", onActivate);
self.addEventListener("message", onMessage);
seld.addEventListener("fetch",onFetch);

main().catch(console.error);

async function main(){
    console.log(`Service Worker ${version} is starting`)
    await sendMessage({requestStatusUpdate:true})
    await cacheLoggedOutFiles();
} 

async function onMessage({data}{
    if(data.statusUpdate){
        ({isOnline, isOnline}) = data.statusUpdate;
    }
})

function onFetch(evt){
    evt.respondWith(router(evt.request));
}

async function router(req){

    var url = new URL(req.url);
    var reqURL=url.pathname;
    var cache = await caches.open(cacheName);

if(url.origin==location.origin){

       try{
           let fetchOptions={
                      method:req.method,
                      headers:req.headers,
                      cache:"no-cache",
                      credential:"omit",
                  }

        res = await fetch(req.url, fetchOptions);
                  if(res.ok){
                      await cache.put(reqURL,res.clone);
                      return res;
                  }

       }catch(err){}

       res.await cache.match(reqURL):
        if(res && res.ok){
              return res.clone();
        }
}

//TODO: figure our CORS requests

}

async function onInstall() {
   self.skipWaiting();
}

async function onActivate(evt){
    evt.waitUntil(handleActivation)
}


async function handleActivation(){
    await clearCaches();
    await cacheLoggedOutFiles(true); //Focefully load everything to cache
    await clients.claim();
    console.log("activated");
}

async function clearCaches(){
    var cacheNames = await caches.keys();
    var oldCacheNames = cacheNames.filter(function matchOldCache(cacheName){
        if(/^ramblings-\d+$/.test(cacheName)){
            let [,cacheVersion]=cacheName.match(/^ramblings-(\d+)$/);
            cacheVersion=(cacheVersion!=null)?Number(cacheVersion)!=version):cacheVersion;
            return (cacheVersion>0 && cacheVersion!==version);
        }
    });

    return Promise.all(oldCacheNames.map(function deleteCache(cacheName){
        return caches.delete(cacheName);
    }));

}

asycn function sendMessage(msg){
    var allClients = await clents.matchAll({includeUncontrolled:true});
    return Promise.all(allClients.map(function clientMsg(clinet){
         var chan = new MessageChannel;
         chan.port1.onmessage = onMessage;
         return client.postMessage(msg, [chan.port2]);
    }))
}

//Caching files
async function cacheLoggedOutFiles(forceReload=false){
        var cache = await caches.open(cacheName);

        return Promise.all(urlsToCache.loggedOut.map(async function requestFile(url){
              try{
                  let res;
                  if(!forceReload){
                      res=await cache.match(url);
                      if(res){
                          return res;
                      }
                  }

                  let fetchOptions={
                      method:"GET",
                      cache:"no-cache",
                      credential:"omit",
                  }

                  res = await fetch(url, fetchOptions);
                  if(res.ok){
                      await cache.put(url,res.clone);
                  }

              }catch(err){

              }
        }))
}