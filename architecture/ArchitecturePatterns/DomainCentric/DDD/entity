An Entity models an individual thing. Each Entity has a unique identity in that you can distinguish its individuality 
from among all other Entities of the same or a different type. Many times, perhaps even most times, 
an Entity will be mutable; that is, its state will change over time. Still, an Entity is not of necessity mutable 
and may be immutable. The main thing that separates an Entity from other modeling tools is 
its uniqueness—its individuality

- It is the unique identity and mutability characteristics that set Entities apart from Value Objects

- When an object is distinguished by its identity, 
rather than its attributes, make this primary to its definition in the model.
Keep the class definition simple and focused on life cycle continuity and identity. Define a means of 
distinguishing each object regardless of its form or history. . . . 
The model must define what it means to be the same thing.

Identity can be created by:
---------------------------
1) User generated
2) Application Generates Identity: String rawId = java.util.UUID.randomUUID().toString();

It uses type 4, employing a cryptographically strong pseudo-random-number generator, which is based on the 
java.security.SecureRandom generator. Type 3 employs a name encryption approach, which uses java.security.MessageDigest. 
We can get a name-based UUID like this:

String rawId = java.util.UUID.nameUUIDFromBytes(

        "Some text".getBytes()).toString();

We can also blend the pseudo-random-number generation with encryption:

SecureRandom randomGenerator = new SecureRandom();
int randomNumber = randomGenerator.nextInt();
String randomDigits = new Integer(randomNumber).toString();
MessageDigest encryptor = MessageDigest.getInstance("SHA-1");
byte[] rawIdBytes = encryptor.digest(randomDigits.getBytes());

Note: For higher-performance domains we can cache any number of UUID instances, refilling the cache in the background. 
If cached UUID instances are lost due to server restart, there are no gaps in identities because they are all based on 
random, manufactured values. Refilling the cache on server restart has no negative consequences of abandoned values.

- With such a large identity, its use could in rare cases be rendered impractical because of the memory overhead. 
In such cases an 8-byte long identity generated by the persistence mechanism would improve matters. 
A smaller, 4-byte integer, with two billion or so unique values, may even suffice.

- Local identity means that Entities held inside an Aggregate need only have uniqueness among other Entities held 
inside the same Aggregate. On the other hand, the Entity serving as an Aggregate Root requires global unique identity.


VVVVIIIIPPPPPP:

- Our own identity generator could use one or more specific UUID segments. 

String rawId = "APM-P-08-14-2012-F36AB21C"; // would be generated
ProductId productId = new ProductId(rawId);
Date productCreationDate =  productId.creationDate();

A client can ask for identity details, such as the date the product was created, and it’s conveniently provided. 
Clients need not understand the raw identity format. 
Now the Product Aggregate Root can expose its creation date without indicating to clients how it is obtained

public class Product extends Entity { 
    private ProductId productId;  //Here product id is the value object

    public Date creationDate() {
        return this.productId().creationDate(); // You get the creation date by querying value object.
    }
}

- You may find identity generation in third-party libraries and frameworks. 
The Apache Commons project has a Commons Id (sandbox) component, which supplies five different identity generators.
Some persistence stores, such as NoSQL Riak and MongoDB, can generate identities for you. 
Normally to save a value in Riak, you use HTTP PUT, which takes a key:
PUT /riak/bucket/key
You may instead use POST without providing a key, 
forcing Riak to generate a unique identity. Still, we do need to think about early 
versus late identity generation.-

- What will serve as a Factory for your application-generated identities? For Aggregate Root identity generation, 
I like to use its Repository:

public class HibernateProductRepository implements ProductRepository  {
    public ProductId nextIdentity() {
        return new ProductId(
                java.util.UUID.randomUUID().toString().toUpperCase());
    }
}

This seems like a natural location for identity generation.


3) Persistence Mechanism Generates Identity:

Preallocation and caching are not an issue if the model can suffice with late identity generation.
Here’s how it’s done with Hibernate and an Oracle sequence:

<id name="id" type="long" column="product_id">
    <generator class="sequence">
        <param name="sequence">product_seq</param>
    </generator>
</id>

Here’s an example of the same approach, but using a MySQL auto-increment column:

<id name="id" type="long" column="product_id">
    <generator class="native"/>
</id>

Sometimes it matters when the identity generation and assignment occur for an Entity.

Early identity:  generation and assignment happen before the Entity is persisted.
Late identity: generation and assignment happen when the Entity is persisted.

Here a Repository supports early generation, serving the next available Oracle sequence using a query:

public ProductId nextIdentity() {
    Long rawProductId = (Long)
        this.session()
            .createSQLQuery(
                "select product_seq.nextval as product_id from dual")
            .addScalar("product_id", Hibernate.LONG)
            .uniqueResult();
    return new ProductId(rawProductId);
}

Here is a reimplementation of the ProductRepository method next-Identity() for MySQL:

public ProductId nextIdentity() {

    long rawId = -1L;

    try {

        PreparedStatement ps =

            this.connection().prepareStatement(

                "update product_seq "

                + "set next_val=LAST_INSERT_ID(next_val + 1)");



        ResultSet rs = ps.executeQuery();



        try {

            rs.next();

            rawId = rs.getLong(1);

        } finally {

            try {

                rs.close();

            } catch(Throwable t) {

                // ignore

            }

        }



    } catch (Throwable t) {

        throw new IllegalStateException(

                "Cannot generate next identity", t);

    }



    return new ProductId(rawId);

}

The last trick is to get a JDBC connection from Hibernate. This can be a bit of a pain, but it’s possible:

Click here to view code image

private Connection connection() {

    SessionFactoryImplementor sfi =

           (SessionFactoryImplementor)sessionFactory;

    ConnectionProvider cp = sfi.getConnectionProvider();

    return cp.getConnection();

}

Without a Connection object we can’t get a ResultSet by executing a PreparedStatement. Without that it’s not possible to use a portable sequence.

Using portable sequences from Oracle, MySQL, and other databases, we have the means to generate more compact, guaranteed unique identities that support pre-insert creation.

Bug if early identity generation is delayed:
-------------------------------------------

There is another problem that can occur when identity generation is delayed until the Entity is persisted. It occurs when 
two or more new Entities must be added to a java.util.Set, but their identity has not yet been assigned, making them equal 
to the other new ones (for example, null, or 0, or -1). 
If the Entity’s equals() method compares identities, those newly added to the Set will appear to be the same object. Only 
the first object added will be contained, and all others will be excluded. This causes a dubious bug whose root cause is 
at first difficult to understand and fix.

To avoid this bug we must do one of two things. Either we change the design to allocate and assign identity early, 
or we refactor the equals() method to compare attributes other than the domain identity. If choosing the equals() 
method approach, it must be implemented as if the Entity is a Value Object. In that case, the same object’s hashCode() 
method must harmonize with the equals() method:

public class User extends Entity  {

    ...

    @Override

    public boolean equals(Object anObject) {

        boolean equalObjects = false;

        if (anObject != null &&

               this.getClass() == anObject.getClass()) {

            User typedObject = (User) anObject;

            equalObjects =

                this.tenantId().equals(typedObject.tenantId()) &&

                this.username().equals(typedObject.username()));

        }

        return equalObjects;

    }



    @Override

    public int hashCode() {

        int hashCode =

            + (151513 * 229)

            + this.tenantId().hashCode()

            + this.username().hashCode();



        return hashCode;

    }

}

- More to the point, when faced with this add-to-Set situation, I prefer early allocation and assignment to the 
Value equality test approach. It is more desirable for Entities to have equals() 
and hashCode() methods that are based on the object’s unique identity rather than other attributes.


Surrogate identity:
------------------

Surrogate Identity
Some ORM tools, such as Hibernate, want to deal with object identity on their own terms. Hibernate prefers the database’s native type, such as a numeric sequence, as the primary identity of each Entity. If the domain requires another kind of identity, it causes an undesirable conflict for Hibernate. To cure this, we need to use two identities. One of the identities is designed for the domain model and adheres to the requirements of the domain. The other is for Hibernate and is known as a surrogate identity.

Creating a surrogate identity is straightforward. Create an attribute on the Entity to hold the type of the surrogate. Generally a long or int does it. Also create a column in the database entity table to hold the unique identity, and place a primary key constraint on it. Then include in the Entity’s Hibernate mapping definition an <id> element. Remember, in this case it has nothing to do with the domain-specific identity. It is being created only for the sake of the ORM, Hibernate.

It’s best to hide the surrogate attribute from the outside world. Because the surrogate is not part of the domain model, visibility constitutes persistence leakage. Although some leakage may be unavoidable, we can take some steps to tuck it away from model developers and clients.

One safeguard employs a Layer Supertype

public abstract class IdentifiedDomainObject

        implements Serializable  {



    private long id= -1;



    public IdentifiedDomainObject() {

        super();

    }



    protected long id() {

        return this.id;

    }



    protected void setId(long anId) {

        this.id= anId;

    }

}

This Layer Supertype is IdentifiedDomainObject, an abstract base class that hides the surrogate primary key from the view of clients using protected accessor methods. Clients will never have to wonder if the methods are for their use since they are not visible outside the Module (9) of the Entity that extends the base class. We could even declare private scope. Hibernate has no problems using method or field reflection with any level of visibility, public to private. Additional Layer Supertypes may add value, such as for supporting optimistic concurrency, as seen in Aggregates (10).

We need to map the surrogate id attribute to the database column through the Hibernate definition. Here class User has its id attribute mapped to the database table column named id:

Click here to view code image

<hibernate-mapping default-cascade="all">

    <class

     name="com.saasovation.identityaccess.domain.model.identity.User"

     table="tbl_user" lazy="true">



        <id

            name="id"

            type="long"

            column="id"

            unsaved-value="-1">



            <generator class="native"/>

        </id>

        ...

    </class>

</hibernate-mapping>

Here is the MySQL table definition to store the User objects:

Click here to view code image

CREATE TABLE `tbl_user` (

    `id` int(11) NOT NULL auto_increment,

    `enablement_enabled` tinyint(1) NOT NULL,

    `enablement_end_date` datetime,

    `enablement_start_date` datetime,

    `password` varchar(32) NOT NULL,

    `tenant_id_id` varchar(36) NOT NULL,

    `username` varchar(25) NOT NULL,

    KEY `k_tenant_id_id` (`tenant_id_id`),

    UNIQUE KEY `k_tenant_id_username` (`tenant_id_id`,`username`),

    PRIMARY KEY (`id`)

) ENGINE=InnoDB;

The first column, id, is the surrogate identity. The last column statement in the definition declares id as the table’s primary key. We can distinguish the surrogate and the domain’s identity. There are two columns, tenant_id_id and username, that provide unique identity for the domain. They are combined to form one unique key named k_tenant_id_username.

There is no need for the domain identity to play the role of database primary key. We allow the surrogate id to serve as the database primary key, which keeps Hibernate happy.

Surrogate database primary keys can be used throughout the data model as foreign keys in other tables, providing referential integrity. This may be a requirement for data management in your enterprise (for example, for audits) or for tools support. The referential integrity is important for Hibernate, too, when wiring tables together to implement the various any-to-any (such as 1:M) mappings. They also support table joins to optimize queries when reading Aggregates out of the database.

Identity Stability:
--------------------
In most cases unique identity must be protected from modification, remaining stable throughout the lifetime of the
Entity to which it is assigned.

Trivial measures may be taken to prevent identity modification. We can hide identity setters from clients. We might 
also create guards in setters to prevent even the Entity itself from changing the state 
of the identity if it already exists. Guards are coded as assertions in Entity setters. 

public class User extends Entity  {
    protected void setUsername(String aUsername) {
        if (this.username != null) {
            throw new IllegalStateException(
                    "The username may not be changed.");
        }
        if (aUsername == null) {
            throw new IllegalArgumentException(

                    "The username may not be set to null.");
        }
        this.username = aUsername;
    }
}

In this example, the username attribute, being the domain identity of the User Entity, 
is mutable only once, and only internally. The setter, method setUsername(), provides self-encapsulation 
that is hidden from clients. When an Entity public behavior self-delegates to the setter, the method checks 
the username attribute to see if it is already non-null. If it is already non-null, indicating an unchangeable 
invariant state, the IllegalStateException is thrown. The exception indicates that username must be maintained 
as a modify-once state.

