An API represents an abstraction of the underlying implementation.
An API is represented by a specification that introduces types. Developers can understand the specifications and use tooling to generate code in multiple languages to implement an API Consumer (software that consumes an API).

An API has defined semantics or behavior to effectively model the exchange of information.

Effective API design enables APIs to be extended to customers or third parties for a business integration.

The API Controller component is intriguing from the perspective of in process routing and acting as a junction point or front 
controller pattern. For API requests and processing this is an important pattern, 
all requests pass through the controller which makes a decision on where the request is directed. 

Infrastructure components like Kubernetes and Service Mesh use network abstractions to route to services, requiring services to 
run inside a managed environment. In some systems east → 
west traffic is managed by the application itself and service discovery techniques are implemented to locate other systems.

ADR:
----
An Architecture Decision Record (ADR) is a document that captures a decision, including the context of how the decision 
was made and the consequences of adopting the decision.

Status

Proposed

Context

The conference owners have requested two new major features to the current conference system, that need to be implemented without disrupting the current system. The conference system will need to be evolved to support a mobile application and an integration with an external CFP system. Both the mobile application and the external CFP system need to be able to access attendees to log in users to the third party service.

Decision

We will take an evolutionary step as documented in Figure 1-4 to split out the Attendee component into a standalone service. This will allow API-First development against the Attendee service and allow the API to be invoked from the legacy conference service. This will also support the ability to design for direct access to the Attendee service to provide user information to the external CFP system.

Consequences

The call to the Attendee service will not be out of process and may introduce a latency that will need to be tested. The Attendee service could become a single point of failure in the architecture and we may need to take steps to mitigate the potential impact of running a single Attendee service.

Also consider,

Decision

Describes a decision that you might need to make when considering an aspect of this book.

Discussion Points

This section helps to identify the key discussions that you should be having when making a decision about your API Architecture.

In this section we will reveal some of the authors experiences that may have influenced the decision. We will help you to identify the key information to inform your decision making process.

Recommendations

We will make specific recommendations that you should consider when creating your ADR, explaining the rationale behind why we are making a specific recommendation.


Checklist: Modelling Exchanges
Table 2-4. Modelling Exchanges Checklist
Decision

What format should we use to model the API for our service?

Discussion Points

Is the exchange a North→South or East→West exchange? Are we in control of the consumer code?

Is there a strong business domain across multiple services or do we want to allow consumers to construct their own queries?

What versioning considerations do we need to have?

What is the deployment/change frequency of the underlying data model.

Is this a high traffic service where bandwidth or performance concerns have been raised?

Recommendations

If the API is consumed by external users REST is the lowest barrier to entry and provides a strong domain model.

If the APIs offered connect well together and users are likely to use the API to query across APIs frequently consider using GraphQL.

If the API is interacting between two services under close control of the producer or the service is proven to be high traffic consider gRPC.



APIs can be divided into 3 categories:
1. Public APIs: Allow user to register with us before they allow to send requests and use the system
2. Private/Internal APIs - used within company
3. Partner APIs - Exposed to users having business relationship with us

Easy use of apis can be achieved using:
1. One way to get certain data or perform task
2. Descriptive names for actions and resources.
3. Exposing only the info and actions that user needs
4. Keeping things consistent all across apis.
5. Check for idempotency
6, Api pagination - Number of items and offset to be provided
7. Async ops
8. Versioning of api