RPC:
---
- Local transparency-> This looks like calling a normal local method in terms of the developer code.
- RPC frameowkr support diff programming languages.
- IDL -> Used to define the api and the datatypes
- IDL -> RPC tool -> Generate code for client and server called client and server stub respectively

Drawback of RPC:
---------------
- local methods are slow [Client does not know how long this would take] and less reliable.
Use async for slow executions. No way client can know if server received the message and the ack message got lost in the network.
Making ops idenpotent can help here.

Good choice when:
----------------
- API provided to diff comapny instead  of an end user app/web page
- Comms between diff components within a large system
- Abstracting away the network comms and focusing only on the action the client wants to perform.

No be good choice when:
-----------------------
- Where we dont want to abstract the network comm away
- When we want to take direct advantage of HTTP cookies or headers.
- RPC revolves more around actions and less around data and resources.
- APIs are data centric and all operation are simply crud.

Frameworks available:
--------------------
- gRPC
- Apache Thrift
- Java RMI

In Json, 3 calls to setup TCP connection and then send json payload.
- Headers are carried -> paln text and heavy and cannot be compressed.
- Serialization and deserialisation
- Api contract
- Client SDK

- Inspired by stubby and dev by google released in 2016
- Framework for inter microservice comms

- Uses http2 by default.
- Non-blocking, streaming bindings.
- Protobuf -> Strict typing, DTO, Service def, language-agnostic, autogenerated bindings for multipel languages.
- Great for mobile apps.

- It is a RPC Framework
- More flexible and action oriented.
- Specific to interservice comms.


Two things:
-----------
- gRPC stream and gRPC unary




