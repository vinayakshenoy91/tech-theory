Checklist: Choosing an API Standard
Table 2-2. API Standards Checklist
Decision

Which API standard should we adopt?

Discussion Points

Does the organization already have other standards within the company? Can we extend those standards to external consumers?

Are we using any third party APIs that we will need to expose to a consumer (e.g. Identity Services) that already have a standard?

What does the impact of not having a standard look like for our consumers?

Recommendations

Pick an API standard that best matches the culture of the Organization and formats of APIs you may already have in the inventory.

Be prepared to evolve and add to a standard any domain/industry specific amendments.

Start with something early to avoid having to break compatibility later for consistency.

Be critical of existing APIs, are they in a format that consumers would understand or is more effort required to offer the content?


https://semver.org/


API Lifecycle:
--------------
Planned

Exposing an API from a technology perspective is quite straightforward, however once it is exposed and consumed we have multiple parties that need to be managed. The planning stage is about advertising that you are building an API to the rest of the API program. This allows a discussion to be had about the API and the scope of what it should cover.

Beta

Involves releasing a version of our API for users to start to integrate with, however this is generally for the purpose of feedback and improving the API. At this stage the producer reserves the right to break compatibility, it is not a versioned API. This helps to get rapid feedback from consumers about the design of the API before settling on a structure. A round of feedback and changes enables the producer to avoid having many major versions at the start of the APIs lifetime.

Live

The API is now versioned and live in production. Any changes from this point onward would be versioned changes. There should only ever be one live API, which marks the most recent major/minor version combination. Whenever a new version is released the current live API moves to deprecated.

Deprecated

When an API is deprecated it is still available for use, but significant new development should not be carried out against it.

When a minor version of a new API is released an API will only be deprecated for a short time, until validation of the new API in production is complete. After the new version is successfully validated a minor version moves to retired, as the new version is backwards compatible and can handle the same features as the previous API.

When a major version of the API is released the older version becomes deprecated. It is likely that will be for weeks or months, as an opportunity must be given to consumers to migrate to the new version. There is likely going to be communication with the consumers, a migration guide and tracking of metrics and usage of the deprecated API.

Retired

The API is retired from production and is no longer accessible.




Where shuld the version sit?
-----------------------------
One often controversial question is how should the major version be exposed to the user. 
One way is to expose the major version in the URL i.e. http://mastering-api.com/v1/attendees. 
From a purely RESTful perspective however the version is not part of the resource. Having the major version 
as part of the URL makes it clear to the consumer what they are consuming. A more RESTful way is to have the 
major version as part of the header, e.g. VERSION: 1. Having the version in a header may be slightly hidden from the consumer. 
A decision would need to be made to be consistent across APIs.



Api spec diff:
---------------
$docker run --rm -t \
   -v $(pwd):/specs:ro \
   openapitools/openapi-diff:latest /specs/original.json /specs/first-name.json

https://learning.oreilly.com/library/view/mastering-api-architecture/9781492090625/ch02.html#masteringapi-CHP-2-SECT-openapi-specification-and-versioning

