@bean -> instantiates a bean and then set values to its properties.

Ex: Without autoconfiguration
@Bean
public DataSource dataSource() {
  return new EmbeddedDatabaseBuilder()
      .setType(H2)
      .addScript("taco_schema.sql")
      .addScripts("user_data.sql", "ingredient_data.sql")
      .build();
}

- If the H2 dependency is available in the runtime classpath, then Spring Boot automatically creates 
in the Spring application context an appropriate DataSource bean, which applies the SQL scripts 
schema.sql and data.sql.


Spring environment abstraction:
-------------------------------

It abstracts the origins of properties so that beans needing those properties can consume them from Spring itself. 
The Spring environment pulls from several property sources, including the following:

- JVM system properties
- Operating system environment variables
- Command-line arguments
- Application property configuration files


Configs:
-------
server.port=9090

java -jar tacocloud-0.0.5-SNAPSHOT.jar --server.port=9090

in OS: export SERVER_PORT=9090

server.port=0 //randomly chosen available port, useful in integration test

Configure database config:
---------------------------

spring:
  datasource:
    url: jdbc:mysql:/ /localhost/tacocloud
    username: tacouser
    password: tacopassword

OR

spring:
  datasource:
    url: jdbc:mysql:/ /localhost/tacocloud
    username: tacouser
    password: tacopassword
    driver-class-name: com.mysql.jdbc.Driver
    schema:
    - order-schema.sql
    - ingredient-schema.sql
    - taco-schema.sql
    - user-schema.sql
    data:
    - ingredients.sql

Spring Boot uses this connection data when autoconfiguring the DataSource bean. 
The DataSource bean will be pooled using the HikariCP connection pool if it’s available on the classpath. 
If not, Spring Boot looks for and uses one of the following other connection pool implementations on the classpath:

- Tomcat JDBC Connection Pool
- Apache Commons DBCP2

Maybe explicit data source configuration isn’t your style. Instead, perhaps you’d prefer to configure your data source in the Java Naming and Directory Interface (JNDI) (http://mng.bz/MvEo) and have Spring look it up from there. In that case, set up your data source by configuring spring.datasource.jndi-name as follows:

spring:
  datasource:
    jndi-name: java:/comp/env/jdbc/tacoCloudDS
If you set the spring.datasource.jndi-name property, the other data source connection properties (if set) are ignored.

Configuring the embedded server:
--------------------------------
https creation -> keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA

server:
  port: 8443
  ssl:
    key-store: file:/ / /path/to/mykeys.jks
    key-store-password: letmein
    key-password: letmein

Configuring logging: By default, the log files rotate once they reach 10 MB in size.
--------------------

src/main/resources/logback.xml

<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
      </pattern>
    </encoder>
  </appender>
  <logger name="root" level="INFO"/>
  <root level="INFO">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>

logging:
  file:
    path: /var/logs/
    file: TacoCloud.log
  level:
    root: WARN
    org:
      springframework:
        security: DEBUG

Using special property values
------------------------------
greeting:
  welcome: You are using ${spring.application.name}.


Property injection of configuration properties:
-----------------------------------------------
- configuration properties are nothing more than properties of beans that have been 
designated to accept configurations from Spring’s environment abstraction.

- To support property injection of configuration properties, 
Spring Boot provides the @ConfigurationProperties annotation.
When placed on any Spring bean, it specifies that the properties of that bean can be 
injected from properties in the Spring environment.


@ConfigurationProperties(prefix="taco.orders")
public class OrderController {
 
  private int pageSize = 20;
 
  public void setPageSize(int pageSize) {
    this.pageSize = pageSize;
  }
 
}

taco:
  orders:
    pageSize: 10


Defining configuration property holders:
---------------------------------------
@Component
@ConfigurationProperties(prefix="taco.orders")
@Data
@Validated
public class OrderProps {
  
  @Min(value=5, message="must be between 5 and 25")
  @Max(value=25, message="must be between 5 and 25")
  private int pageSize = 20;
 
}

Note: To create metadata for your custom configuration properties, you’ll need to create a file under 
the META-INF (e.g., in the project under src/main/resources/META-INF) 
named additional-spring-configuration-metadata.json.

{"properties": [{
  "name": "taco.orders.page-size",
  "type": "java.lang.String",
  "description": "A description for 'taco.orders.page-size'"
}]}


Configuring with profiles:
==========================

