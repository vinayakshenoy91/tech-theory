To separate protocol-specific error handling from the business logic in the REST controllers, that is, the API implementations, I have created a utility class, GlobalControllerExceptionHandler.java, in the util project that's annotated as @RestControllerAdvice.

For each Java exception that the API implementations throw, the utility class has an exception handler method that maps the Java exception to a proper HTTP response, that is, with a proper HTTP status and HTTP response body.

For example, if an API implementation class throws InvalidInputException, the utility class will map it to an HTTP response with the status code set to 422 (UNPROCESSABLE_ENTITY). 


@ResponseStatus(UNPROCESSABLE_ENTITY)
@ExceptionHandler(InvalidInputException.class)
public @ResponseBody HttpErrorInfo handleInvalidInputException(
    ServerHttpRequest request, InvalidInputException ex) {

    return createHttpErrorInfo(UNPROCESSABLE_ENTITY, request, ex);
}