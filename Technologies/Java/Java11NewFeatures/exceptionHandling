Exceptions
------------
- Specific names for specific errors
- Flower brackets are mandatory for try-catch unlike if else
- NumberFormatException > IllegalArgumentException > RuntimeException 
- FileNotFound  > IOException
- If you are putting multi-catch, put only the parent exception. If you put both parent and child, then it won't compile.
Pull Illegal argument exception of both NumberFormat and IllegalArgumentException are present

- use 'throw' when you throw an exception and use 'throws' when you throw it from method signature.
- Avoid adding runtime exceptions in method signatures.

- If parent method does not throw exception, the child method overriden cannot throw.
If the parent method throws and exception in method signature, then child method  shown throw exception which are at same or 
lower level.If the parent that IOException, child can thow FileNotFound  and IOException and not generic exception class 

- Java.lang.Object -> java.lang. Throwable -> 1) Exception -> Runtime Exception 2) Error(Bad hapoened and no recoverable)

Common errors are:
-------------------
ExceptionInInitilizerError -> If it throws erorr wrto static blocks/variable
StackOverflowError
NoClassDefFoundError
OutOfMemoryError -> Create objects continuously and run with heap size of -Xmx1m 


Notes:
-------
The try statements are like methods in that the curly braces are required even if there is only one statement inside the code blocks, while if statements and loops are special and allow you to omit the curly braces.






Try-catch syntax:
------------------
try{

}catch(ExceptionType ex){

}finally{

}

Multi catch: // Finally should always come after catch
------------

try{

}catch(Exception1 | Exception2 ex){ //} catch (ArrayIndexOutOfBoundsException | NumberFormatException e) { 

}finally{

}

Only this will compile: catch(Exception1 | Exception2 | Exception3 e)  //rest all will not.


System exit:
-------------
try{
    System.exit(0); // Stopa nd exit right away
}finally{  // This code will not run 
    System.out.println("This wont print");
}

SYSTEM.EXIT()
There is one exception to “the finally block always be executed” rule: 
Java defines a method that you call as System.exit(). It takes an integer parameter that 
represents the error code that gets returned.

try {
   System.exit(0);
} finally {
   System.out.print("Never going to get here");  // Not printed
}
System.exit() tells Java, “Stop. End the program right now. Do not pass go. 
Do not collect $200.” When System.exit() is called in the try or catch block, the finally block does not run.


try with resource: This can exist without catch or finally unlike previous ones.
-------------------
- If the resource does not throw, you need not handle. else you need to handle and have a catch
- Resource will be closed in a reverse way it is declared
- The resource should implement a autocloseable interface that has a close method in it

try(resource1;resource2){

}

4:  public void readFile(String file) {
5:     try (FileInputStream is = new FileInputStream("myfile.txt")) {
6:        // Read file data
7:     } catch (IOException e) {
8:        e.printStackTrace();
9:     }
10: }


Notice that one or more resources can be opened in the try clause. When there are multiple resources opened, they are closed 
in the reverse order from which they were created. Also, notice that parentheses are used to list those resources, 
and semicolons are used to separate the declarations. This works just like declaring multiple indexes in a for loop.

try(FileInputStream in = new FileInputStream("data.txt");FileOutputStream in = new FileOutputStream("data.txt");){

}

In fact, if the code within the try block throws a checked exception not declared by the method 
in which it is defined or handled by another try/catch block, then it will need to be handled 
by the catch block. Also, the catch and finally blocks are run in addition to the implicit one 
that closes the resources. For the exam, you need to know that the implicit finally block runs 
before any programmer-coded ones.

               0 finally blocks	 | 1 finally block	| 2 or more finally blocks
0 catch blocks	       Not legal	Legal	          Not legal
1 or more catch blocks	Legal	    Legal	          Not legal

                       0 finally blocks|1 finally block |2 or more finally blocks
0 catch blocks           	Legal	           Legal	Not legal
1 or more catch blocks	    Legal	           Legal	Not legal

AUTOCLOSEABLE
You can’t just put any random class in a try-with-resources statement. Java requires classes used in a 
try-with-resources implement the AutoCloseable interface, which includes a void close() method

You can declare a resource using var as the data type in a try-with-resources statement, since resources are local variables.



try (var f = new BufferedInputStream(new FileInputStream("it.txt"))) {
   // Process file
}
Declaring resources is a common situation where using var is quite helpful, as it shortens the already long line of code.


Scope of Try-with-Resources
The resources created in the try clause are in scope only within the try block. 
This is another way to remember that the implicit finally runs before any catch/finally blocks that you code yourself.


Custom exception:
------------------
- If a client is able to recover from exception, when make it a checked exception else unchecked.
Unchecked in the sense fix is required from client side

//Checked custom exception
class Custom1 extends Exception{
   public Custom1(String msg){
       super(msg);
   }
}

//Unchecked custom exception
class Custom2 extends RuntimeException{

}


Checked Exceptions:
-------------------
A checked exception is an exception that must be declared or handled by the application code where it is thrown. In Java, 
checked exceptions all inherit Exception but not 
RuntimeException. Checked exceptions tend to be more anticipated—for example, trying to read a file that doesn’t exist.
Checked exceptions also include any class that inherits Throwable, but not Error or RuntimeException. For example, 
a class that directly extends Throwable would be a checked exception.

Java has a rule called the handle or declare rule. The handle or declare rule means that all checked exceptions that could be thrown 
within a method are either wrapped in compatible try and catch blocks or declared in the method signature.

Because checked exceptions tend to be anticipated, Java enforces the rule that the programmer must do something to show the exception 
was thought about. Maybe it was handled in the method. 
Or maybe the method declares that it can’t handle the exception and someone else should.

While only checked exceptions must be handled or declared in Java, unchecked exceptions (which we will present in the next section) may also be handled or declared. The distinction is that checked exceptions must be handled or declared, while unchecked exceptions can be optionally handled or declared.


Unchecked Exceptions:
--------------------
An unchecked exception is any exception that does not need to be declared or handled by the application code where it is thrown. Unchecked exceptions are often referred to as runtime exceptions, although in Java, unchecked exceptions include any class that inherits RuntimeException or Error.

A runtime exception is defined as the RuntimeException class and its subclasses. Runtime exceptions tend to be unexpected but not necessarily fatal. For example, accessing an invalid array index is unexpected. Even though they do inherit the Exception class, they are not checked exceptions.

RUNTIME VS. AT THE TIME THE PROGRAM IS RUN
A runtime (unchecked) exception is a specific type of exception. All exceptions occur at the time that the program is run. (The alternative is compile time, which would be a compiler error.) People don’t refer to them as “run time” exceptions because that would be too easy to confuse with runtime! When you see runtime, it means unchecked.

An unchecked exception can often occur on nearly any line of code, as it is not required to be handled or declared. For example, a NullPointerException can be thrown in the body of the following method if the input reference is null:


THROW VS. THROWS:
-----------------
Anytime you see throw or throws on the exam, make sure the correct one is being used. The throw keyword is used as a statement inside a code block to throw a new exception or rethrow an existing exception, while the throws keyword is used only at the end of a method declaration to indicate what exceptions it supports. On the exam, you might start reading a long class definition only to realize the entire thing does not compile due to the wrong keyword being used.


Types of exceptions and errors

Type	How to recognize	Okay for program to catch?	Is program required to handle or declare?
Runtime exception	Subclass of RuntimeException	Yes	No
Checked exception	Subclass of Exception but not subclass of RuntimeException	Yes	Yes
Error	Subclass of Error	No	No



RUNTIMEEXCEPTION CLASSES:
--------------------------
RuntimeException and its subclasses are unchecked exceptions that don’t have to be handled or declared. They can be thrown by the programmer or by the JVM. Common RuntimeException classes include the following:

ArithmeticException Thrown when code attempts to divide by zero

ArrayIndexOutOfBoundsException Thrown when code uses an illegal index to access an array

ClassCastException Thrown when an attempt is made to cast an object to a class of which it is not an instance

NullPointerException Thrown when there is a null reference where an object is required

IllegalArgumentException Thrown by the programmer to indicate that a method has been passed an illegal or inappropriate argument

NumberFormatException Subclass of IllegalArgumentException thrown when an attempt is made to convert a string to a numeric type but the string doesn’t have an appropriate format

ArithmeticException
Trying to divide an int by zero gives an undefined result. When this occurs, the JVM will throw an ArithmeticException:

int answer = 11 / 0;
Running this code results in the following output:

Exception in thread "main" java.lang.ArithmeticException: / by zero
Java doesn’t spell out the word divide. That’s okay, though, because we know that / is the division operator and that Java is trying to tell you division by zero occurred.


NumberFormatException
Java provides methods to convert strings to numbers. When these are passed an invalid value, they throw a NumberFormatException. The idea is similar to IllegalArgumentException. Since this is a common problem, Java gives it a separate class. In fact, NumberFormatException is a subclass of IllegalArgumentException. Here’s an example of trying to convert something non-numeric into an int:

Integer.parseInt("abc");
The output looks like this:

Exception in thread "main"
java.lang.NumberFormatException: For input string: "abc"
For the exam, you need to know that NumberFormatException is a subclass of IllegalArgumentException


HECKED EXCEPTION CLASSES
Checked exceptions have Exception in their hierarchy but not RuntimeException. They must be handled or declared. Common checked exceptions include the following:

IOException Thrown programmatically when there’s a problem reading or writing a file

FileNotFoundException Subclass of IOException thrown programmatically when code tries to reference a file that does not exist

For the exam, you need to know that these are both checked exceptions. You also need to know that FileNotFoundException is a subclass of IOException. You’ll see shortly why that matters.

ERROR CLASSES
Errors are unchecked exceptions that extend the Error class. They are thrown by the JVM and should not be handled or declared. Errors are rare, but you might see these:

ExceptionInInitializerError Thrown when a static initializer throws an exception and doesn’t handle it

StackOverflowError Thrown when a method calls itself too many times (This is called infinite recursion because the method typically calls itself without end.)

NoClassDefFoundError Thrown when a class that the code uses is available at compile time but not runtime

ExceptionInInitializerError
Java runs static initializers the first time a class is used. If one of the static initializers throws an exception, Java can’t start using the class. It declares defeat by throwing an ExceptionInInitializerError. This code throws an ArrayIndexOutOfBounds in a static initializer:

static {
   int[] countsOfMoose = new int[3];
   int num = countsOfMoose[-1];
}
public static void main(String... args) { }
This code yields information about the error and the underlying exception:

Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: java.lang.ArrayIndexOutOfBoundsException: -1 out of bounds for length 3
When executed, you get an ExceptionInInitializerError because the error happened in a static initializer. That information alone wouldn’t be particularly useful in fixing the problem. Therefore, Java also tells you the original cause of the problem: the ArrayIndexOutOfBoundsException that you need to fix.

The ExceptionInInitializerError is an error because Java failed to load the whole class. This failure prevents Java from continuing.

NoClassDefFoundError
A NoClassDefFoundError occurs when Java can’t find the class at runtime. Generally, this means a library available when the code was compiled is not available when the code is executed.


Rules:
------

Following Order of Operation
You’ve learned two new rules for the order in which code runs in a try-with-resources statement:

Resources are closed after the try clause ends and before any catch/finally clauses.
Resources are closed in the reverse order from which they were created.

Let’s review these principles with a more complex example. First, we define a custom class that you can use with a 
try-with-resources statement, as it implements AutoCloseable.

public class MyFileClass implements AutoCloseable {
   private final int num;
   public MyFileClass(int num) { this.num = num; }
   public void close() {
      System.out.println("Closing: " + num);
   }
}
This is a pretty simple class that prints the number, set by the constructor, when a resource is closed. 
Based on these rules, can you figure out what this method prints?

public static void main(String... xyz) {
   try (MyFileClass a1 = new MyFileClass(1);
         MyFileClass a2 = new MyFileClass(2)) {
      throw new RuntimeException();
   } catch (Exception e) {
      System.out.println("ex");
   } finally {
      System.out.println("finally");
   }
}

Since the resources are closed in the reverse order from which they were opened, we have Closing: 2 and then Closing: 1. 
After that, the catch block and finally block are run—just as they are in a regular try statement. The output is as follows:

Closing: 2
Closing: 1
ex
finally

TRY-WITH-RESOURCES GUARANTEES:
-------------------------------
Does a try-with-resources statement guarantee a resource will be closed? 
Although this is beyond the scope of the exam, the short answer is “no.” 
The try-with-resources statement guarantees only the close() method will be called. 
If the close() method encounters an exception of its own or the method is implemented poorly, 
a resource leak can still occur. For the exam, you just need to know try-with-resources 
is guaranteed to call the close() method on the resource.



Test for exception:
---------------------

When you’re calling a method that throws an exception, the rules are the same as within a method. 
Do you see why the following doesn’t compile?


class NoMoreCarrotsException extends Exception {}
public class Bunny {
   public static void main(String[] args) {
      eatCarrot(); // DOES NOT COMPILE
   }
   private static void eatCarrot() throws NoMoreCarrotsException {
   }
}
The problem is that NoMoreCarrotsException is a checked exception. Checked exceptions must be handled or declared. 
The code would compile if you changed the main() method to either of these:

   public static void main(String[] args)
         throws NoMoreCarrotsException { // declare exception
      eatCarrot();
   }
 
   public static void main(String[] args) {
      try {
         eatCarrot();
      } catch (NoMoreCarrotsException e ) { // handle exception
         System.out.print("sad rabbit");
      }
   }
You might have noticed that eatCarrot() didn’t actually throw an exception; it just declared that it could. 
This is enough for the compiler to require the caller to handle or declare the exception.


DECLARING AND OVERRIDING METHODS WITH EXCEPTIONS:
--------------------------------------------------
Now that you have a deeper understanding of exceptions, let’s look at overriding methods with exceptions in the method declaration. When a class overrides a method from a superclass or implements a method from an interface, it’s not allowed to add new checked exceptions to the method signature. For example, this code isn’t allowed:

class CanNotHopException extends Exception { }
class Hopper {
   public void hop() { }
}
class Bunny extends Hopper {
   public void hop() throws CanNotHopException { } // DOES NOT COMPILE
}
Java knows hop() isn’t allowed to throw any checked exceptions because the hop() method in the superclass Hopper doesn’t declare any. Imagine what would happen if the subclasses versions of the method could add checked exceptions—you could write code that calls Hopper’s hop() method and not handle any exceptions. Then if Bunny were used in its place, the code wouldn’t know to handle or declare CanNotHopException.

An overridden method in a subclass is allowed to declare fewer exceptions than the superclass or interface. This is legal because callers are already handling them.

class Hopper {
   public void hop() throws CanNotHopException { }
}
class Bunny extends Hopper {
   public void hop()  { }
}
An overridden method not declaring one of the exceptions thrown by the parent method is similar to the method declaring it throws an exception that it never actually throws. This is perfectly legal.

Similarly, a class is allowed to declare a subclass of an exception type. The idea is the same. The superclass or interface has already taken care of a broader type. Here’s an example:

class Hopper {
   public void hop() throws Exception { }
}
class Bunny extends Hopper {
   public void hop() throws CanNotHopException { }
}
Bunny could declare that it throws Exception directly, or it could declare that it throws a more specific type of Exception. It could even declare that it throws nothing at all.

This rule applies only to checked exceptions. The following code is legal because it has an unchecked exception in the subclass’s version:

class Hopper {
   public void hop() { }
}
class Bunny extends Hopper {
   public void hop() throws IllegalStateException { }
}
The reason that it’s okay to declare new unchecked exceptions in a subclass method is that the declaration is redundant. Methods are free to throw any unchecked exceptions they want without mentioning them in the method declaration.

