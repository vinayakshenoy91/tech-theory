- Generator retuns an object. 
- Not stored in memory
- Iterate over elements of list as required
- If you want to iterate over a list that hogs memory and is very large, you can use generators.

Syntax is very similar to list comprehensions, replace list comprehension with round bracket:

ex: 
result = (num for num in range(6))
for num in result:
    print(num)

- It can also be passed ot next: //Lazy evaluation
print(next(result))

Example:
--------
# Create generator object: result
result = (num for num in range(31))

# Print the first 5 values
print(next(result))
print(next(result))
print(next(result))
print(next(result))
print(next(result))

# Print the rest of the values
for value in result:
    print(value)


Generator:
----------
- Produces generator object
- Defined like regular function - def
- Yields a sequence of values instead of returning a single value.
- Generates a value with yield keyword

def num_seq(n):
    i=0
    while i<n:
      yield i
      i+=1

Complete example of a genertor fn ==> 

# Create a list of strings
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Define generator function get_lengths
def get_lengths(input_list):
    """Generator function that yields the
    length of the strings in input_list."""

    # Yield the length of a string
    for person in input_list:
        yield len(person)

# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)